// Generated by gencpp from file flexbe_msgs/StateInstantiation.msg
// DO NOT EDIT!


#ifndef FLEXBE_MSGS_MESSAGE_STATEINSTANTIATION_H
#define FLEXBE_MSGS_MESSAGE_STATEINSTANTIATION_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <flexbe_msgs/OutcomeCondition.h>

namespace flexbe_msgs
{
template <class ContainerAllocator>
struct StateInstantiation_
{
  typedef StateInstantiation_<ContainerAllocator> Type;

  StateInstantiation_()
    : state_path()
    , state_class()
    , initial_state_name()
    , input_keys()
    , output_keys()
    , cond_outcome()
    , cond_transition()
    , behavior_class()
    , parameter_names()
    , parameter_values()
    , position()
    , outcomes()
    , transitions()
    , autonomy()
    , userdata_keys()
    , userdata_remapping()  {
      position.assign(0.0);
  }
  StateInstantiation_(const ContainerAllocator& _alloc)
    : state_path(_alloc)
    , state_class(_alloc)
    , initial_state_name(_alloc)
    , input_keys(_alloc)
    , output_keys(_alloc)
    , cond_outcome(_alloc)
    , cond_transition(_alloc)
    , behavior_class(_alloc)
    , parameter_names(_alloc)
    , parameter_values(_alloc)
    , position()
    , outcomes(_alloc)
    , transitions(_alloc)
    , autonomy(_alloc)
    , userdata_keys(_alloc)
    , userdata_remapping(_alloc)  {
  (void)_alloc;
      position.assign(0.0);
  }



   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _state_path_type;
  _state_path_type state_path;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _state_class_type;
  _state_class_type state_class;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _initial_state_name_type;
  _initial_state_name_type initial_state_name;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _input_keys_type;
  _input_keys_type input_keys;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _output_keys_type;
  _output_keys_type output_keys;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _cond_outcome_type;
  _cond_outcome_type cond_outcome;

   typedef std::vector< ::flexbe_msgs::OutcomeCondition_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::flexbe_msgs::OutcomeCondition_<ContainerAllocator> >::other >  _cond_transition_type;
  _cond_transition_type cond_transition;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _behavior_class_type;
  _behavior_class_type behavior_class;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _parameter_names_type;
  _parameter_names_type parameter_names;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _parameter_values_type;
  _parameter_values_type parameter_values;

   typedef boost::array<float, 2>  _position_type;
  _position_type position;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _outcomes_type;
  _outcomes_type outcomes;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _transitions_type;
  _transitions_type transitions;

   typedef std::vector<int8_t, typename ContainerAllocator::template rebind<int8_t>::other >  _autonomy_type;
  _autonomy_type autonomy;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _userdata_keys_type;
  _userdata_keys_type userdata_keys;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _userdata_remapping_type;
  _userdata_remapping_type userdata_remapping;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(CLASS_STATEMACHINE)
  #undef CLASS_STATEMACHINE
#endif
#if defined(_WIN32) && defined(CLASS_CONCURRENCY)
  #undef CLASS_CONCURRENCY
#endif
#if defined(_WIN32) && defined(CLASS_PRIORITY)
  #undef CLASS_PRIORITY
#endif
#if defined(_WIN32) && defined(CLASS_BEHAVIOR)
  #undef CLASS_BEHAVIOR
#endif


  static const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  CLASS_STATEMACHINE;
  static const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  CLASS_CONCURRENCY;
  static const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  CLASS_PRIORITY;
  static const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  CLASS_BEHAVIOR;

  typedef boost::shared_ptr< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> const> ConstPtr;

}; // struct StateInstantiation_

typedef ::flexbe_msgs::StateInstantiation_<std::allocator<void> > StateInstantiation;

typedef boost::shared_ptr< ::flexbe_msgs::StateInstantiation > StateInstantiationPtr;
typedef boost::shared_ptr< ::flexbe_msgs::StateInstantiation const> StateInstantiationConstPtr;

// constants requiring out of line definition

   
   template<typename ContainerAllocator> const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > 
      StateInstantiation_<ContainerAllocator>::CLASS_STATEMACHINE =
        
          ":STATEMACHINE"
        
        ;
   

   
   template<typename ContainerAllocator> const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > 
      StateInstantiation_<ContainerAllocator>::CLASS_CONCURRENCY =
        
          ":CONCURRENCY"
        
        ;
   

   
   template<typename ContainerAllocator> const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > 
      StateInstantiation_<ContainerAllocator>::CLASS_PRIORITY =
        
          ":PRIORITY"
        
        ;
   

   
   template<typename ContainerAllocator> const std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > 
      StateInstantiation_<ContainerAllocator>::CLASS_BEHAVIOR =
        
          ":BEHAVIOR"
        
        ;
   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::flexbe_msgs::StateInstantiation_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::flexbe_msgs::StateInstantiation_<ContainerAllocator1> & lhs, const ::flexbe_msgs::StateInstantiation_<ContainerAllocator2> & rhs)
{
  return lhs.state_path == rhs.state_path &&
    lhs.state_class == rhs.state_class &&
    lhs.initial_state_name == rhs.initial_state_name &&
    lhs.input_keys == rhs.input_keys &&
    lhs.output_keys == rhs.output_keys &&
    lhs.cond_outcome == rhs.cond_outcome &&
    lhs.cond_transition == rhs.cond_transition &&
    lhs.behavior_class == rhs.behavior_class &&
    lhs.parameter_names == rhs.parameter_names &&
    lhs.parameter_values == rhs.parameter_values &&
    lhs.position == rhs.position &&
    lhs.outcomes == rhs.outcomes &&
    lhs.transitions == rhs.transitions &&
    lhs.autonomy == rhs.autonomy &&
    lhs.userdata_keys == rhs.userdata_keys &&
    lhs.userdata_remapping == rhs.userdata_remapping;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::flexbe_msgs::StateInstantiation_<ContainerAllocator1> & lhs, const ::flexbe_msgs::StateInstantiation_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace flexbe_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> >
{
  static const char* value()
  {
    return "1c6026e288cfff7ab6c8308ee1db66f1";
  }

  static const char* value(const ::flexbe_msgs::StateInstantiation_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x1c6026e288cfff7aULL;
  static const uint64_t static_value2 = 0xb6c8308ee1db66f1ULL;
};

template<class ContainerAllocator>
struct DataType< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> >
{
  static const char* value()
  {
    return "flexbe_msgs/StateInstantiation";
  }

  static const char* value(const ::flexbe_msgs::StateInstantiation_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Describes a single instantiation of a state\n"
"\n"
"# Path of this state inside the behavior\n"
"# Last segment of the path is the name of this state\n"
"# e.g. \"/Inner_Statemachine/This_State\"\n"
"string state_path\n"
"\n"
"# Specifies the class implementing this state\n"
"# Use one of the provided CLASS constants if this is not a primitive state\n"
"# e.g. \"CalculationState\"\n"
"string CLASS_STATEMACHINE 	= :STATEMACHINE\n"
"string CLASS_CONCURRENCY 	= :CONCURRENCY\n"
"string CLASS_PRIORITY 		= :PRIORITY\n"
"string CLASS_BEHAVIOR 		= :BEHAVIOR\n"
"string state_class\n"
"\n"
"\n"
"\n"
"# Only relevant for state machine, priority, and concurrency\n"
"# Name of the initial state / state to be monitored\n"
"string initial_state_name\n"
"# Input and output keys (can be remapped below)\n"
"string[] input_keys\n"
"string[] output_keys\n"
"\n"
"# Only relevant for concurrency\n"
"# Outcome conditions\n"
"string[] cond_outcome\n"
"OutcomeCondition[] cond_transition\n"
"\n"
"# Only relevant for behavior\n"
"# Name of the class implementing this state\n"
"string behavior_class\n"
"\n"
"# Only relevant for primitive state\n"
"# List of parameter names and values of this state\n"
"# Order of names and values has to match\n"
"string[] parameter_names\n"
"string[] parameter_values\n"
"\n"
"\n"
"\n"
"# Position of this state in the editor [x,y]\n"
"float32[2] position\n"
"\n"
"# Outcomes of this state\n"
"# Defines the order of the lists: transitions, autonomy\n"
"string[] outcomes\n"
"# Transition targets (state names or container outcomes) of the outcomes\n"
"string[] transitions\n"
"# Required autonomy level of the outcomes\n"
"int8[] autonomy\n"
"\n"
"# Userdata of this state\n"
"# Merges own input_keys and output_keys, no duplicates\n"
"string[] userdata_keys\n"
"# Remapping of the corresponding own key (= key used by container)\n"
"string[] userdata_remapping\n"
"================================================================================\n"
"MSG: flexbe_msgs/OutcomeCondition\n"
"# Defines a conjunction of required state outcomes in order to return a concurrency outcome\n"
"string[] state_name\n"
"string[] state_outcome\n"
;
  }

  static const char* value(const ::flexbe_msgs::StateInstantiation_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.state_path);
      stream.next(m.state_class);
      stream.next(m.initial_state_name);
      stream.next(m.input_keys);
      stream.next(m.output_keys);
      stream.next(m.cond_outcome);
      stream.next(m.cond_transition);
      stream.next(m.behavior_class);
      stream.next(m.parameter_names);
      stream.next(m.parameter_values);
      stream.next(m.position);
      stream.next(m.outcomes);
      stream.next(m.transitions);
      stream.next(m.autonomy);
      stream.next(m.userdata_keys);
      stream.next(m.userdata_remapping);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct StateInstantiation_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::flexbe_msgs::StateInstantiation_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::flexbe_msgs::StateInstantiation_<ContainerAllocator>& v)
  {
    s << indent << "state_path: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.state_path);
    s << indent << "state_class: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.state_class);
    s << indent << "initial_state_name: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.initial_state_name);
    s << indent << "input_keys[]" << std::endl;
    for (size_t i = 0; i < v.input_keys.size(); ++i)
    {
      s << indent << "  input_keys[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.input_keys[i]);
    }
    s << indent << "output_keys[]" << std::endl;
    for (size_t i = 0; i < v.output_keys.size(); ++i)
    {
      s << indent << "  output_keys[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.output_keys[i]);
    }
    s << indent << "cond_outcome[]" << std::endl;
    for (size_t i = 0; i < v.cond_outcome.size(); ++i)
    {
      s << indent << "  cond_outcome[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.cond_outcome[i]);
    }
    s << indent << "cond_transition[]" << std::endl;
    for (size_t i = 0; i < v.cond_transition.size(); ++i)
    {
      s << indent << "  cond_transition[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::flexbe_msgs::OutcomeCondition_<ContainerAllocator> >::stream(s, indent + "    ", v.cond_transition[i]);
    }
    s << indent << "behavior_class: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.behavior_class);
    s << indent << "parameter_names[]" << std::endl;
    for (size_t i = 0; i < v.parameter_names.size(); ++i)
    {
      s << indent << "  parameter_names[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.parameter_names[i]);
    }
    s << indent << "parameter_values[]" << std::endl;
    for (size_t i = 0; i < v.parameter_values.size(); ++i)
    {
      s << indent << "  parameter_values[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.parameter_values[i]);
    }
    s << indent << "position[]" << std::endl;
    for (size_t i = 0; i < v.position.size(); ++i)
    {
      s << indent << "  position[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.position[i]);
    }
    s << indent << "outcomes[]" << std::endl;
    for (size_t i = 0; i < v.outcomes.size(); ++i)
    {
      s << indent << "  outcomes[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.outcomes[i]);
    }
    s << indent << "transitions[]" << std::endl;
    for (size_t i = 0; i < v.transitions.size(); ++i)
    {
      s << indent << "  transitions[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.transitions[i]);
    }
    s << indent << "autonomy[]" << std::endl;
    for (size_t i = 0; i < v.autonomy.size(); ++i)
    {
      s << indent << "  autonomy[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.autonomy[i]);
    }
    s << indent << "userdata_keys[]" << std::endl;
    for (size_t i = 0; i < v.userdata_keys.size(); ++i)
    {
      s << indent << "  userdata_keys[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.userdata_keys[i]);
    }
    s << indent << "userdata_remapping[]" << std::endl;
    for (size_t i = 0; i < v.userdata_remapping.size(); ++i)
    {
      s << indent << "  userdata_remapping[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.userdata_remapping[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // FLEXBE_MSGS_MESSAGE_STATEINSTANTIATION_H
