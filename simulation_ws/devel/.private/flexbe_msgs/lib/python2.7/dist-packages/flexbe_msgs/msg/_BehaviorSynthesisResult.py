# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from flexbe_msgs/BehaviorSynthesisResult.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import flexbe_msgs.msg

class BehaviorSynthesisResult(genpy.Message):
  _md5sum = "088bd6aee1c7ee2902db2babfd6af1c2"
  _type = "flexbe_msgs/BehaviorSynthesisResult"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======

# Provides feedback regarding possibly occured errors
SynthesisErrorCodes error_code

# Result of behavior synthesis as a list of state instantiations
StateInstantiation[] states


================================================================================
MSG: flexbe_msgs/SynthesisErrorCodes
int32 value

# success
int32 SUCCESS = 1

# all other values will be considered as any sort of error
================================================================================
MSG: flexbe_msgs/StateInstantiation
# Describes a single instantiation of a state

# Path of this state inside the behavior
# Last segment of the path is the name of this state
# e.g. "/Inner_Statemachine/This_State"
string state_path

# Specifies the class implementing this state
# Use one of the provided CLASS constants if this is not a primitive state
# e.g. "CalculationState"
string CLASS_STATEMACHINE 	= :STATEMACHINE
string CLASS_CONCURRENCY 	= :CONCURRENCY
string CLASS_PRIORITY 		= :PRIORITY
string CLASS_BEHAVIOR 		= :BEHAVIOR
string state_class



# Only relevant for state machine, priority, and concurrency
# Name of the initial state / state to be monitored
string initial_state_name
# Input and output keys (can be remapped below)
string[] input_keys
string[] output_keys

# Only relevant for concurrency
# Outcome conditions
string[] cond_outcome
OutcomeCondition[] cond_transition

# Only relevant for behavior
# Name of the class implementing this state
string behavior_class

# Only relevant for primitive state
# List of parameter names and values of this state
# Order of names and values has to match
string[] parameter_names
string[] parameter_values



# Position of this state in the editor [x,y]
float32[2] position

# Outcomes of this state
# Defines the order of the lists: transitions, autonomy
string[] outcomes
# Transition targets (state names or container outcomes) of the outcomes
string[] transitions
# Required autonomy level of the outcomes
int8[] autonomy

# Userdata of this state
# Merges own input_keys and output_keys, no duplicates
string[] userdata_keys
# Remapping of the corresponding own key (= key used by container)
string[] userdata_remapping
================================================================================
MSG: flexbe_msgs/OutcomeCondition
# Defines a conjunction of required state outcomes in order to return a concurrency outcome
string[] state_name
string[] state_outcome"""
  __slots__ = ['error_code','states']
  _slot_types = ['flexbe_msgs/SynthesisErrorCodes','flexbe_msgs/StateInstantiation[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       error_code,states

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(BehaviorSynthesisResult, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.error_code is None:
        self.error_code = flexbe_msgs.msg.SynthesisErrorCodes()
      if self.states is None:
        self.states = []
    else:
      self.error_code = flexbe_msgs.msg.SynthesisErrorCodes()
      self.states = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.error_code.value
      buff.write(_get_struct_i().pack(_x))
      length = len(self.states)
      buff.write(_struct_I.pack(length))
      for val1 in self.states:
        _x = val1.state_path
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.state_class
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.initial_state_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.input_keys)
        buff.write(_struct_I.pack(length))
        for val2 in val1.input_keys:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.output_keys)
        buff.write(_struct_I.pack(length))
        for val2 in val1.output_keys:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.cond_outcome)
        buff.write(_struct_I.pack(length))
        for val2 in val1.cond_outcome:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.cond_transition)
        buff.write(_struct_I.pack(length))
        for val2 in val1.cond_transition:
          length = len(val2.state_name)
          buff.write(_struct_I.pack(length))
          for val3 in val2.state_name:
            length = len(val3)
            if python3 or type(val3) == unicode:
              val3 = val3.encode('utf-8')
              length = len(val3)
            buff.write(struct.Struct('<I%ss'%length).pack(length, val3))
          length = len(val2.state_outcome)
          buff.write(_struct_I.pack(length))
          for val3 in val2.state_outcome:
            length = len(val3)
            if python3 or type(val3) == unicode:
              val3 = val3.encode('utf-8')
              length = len(val3)
            buff.write(struct.Struct('<I%ss'%length).pack(length, val3))
        _x = val1.behavior_class
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.parameter_names)
        buff.write(_struct_I.pack(length))
        for val2 in val1.parameter_names:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.parameter_values)
        buff.write(_struct_I.pack(length))
        for val2 in val1.parameter_values:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        buff.write(_get_struct_2f().pack(*val1.position))
        length = len(val1.outcomes)
        buff.write(_struct_I.pack(length))
        for val2 in val1.outcomes:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.transitions)
        buff.write(_struct_I.pack(length))
        for val2 in val1.transitions:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.autonomy)
        buff.write(_struct_I.pack(length))
        pattern = '<%sb'%length
        buff.write(struct.Struct(pattern).pack(*val1.autonomy))
        length = len(val1.userdata_keys)
        buff.write(_struct_I.pack(length))
        for val2 in val1.userdata_keys:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.userdata_remapping)
        buff.write(_struct_I.pack(length))
        for val2 in val1.userdata_remapping:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.error_code is None:
        self.error_code = flexbe_msgs.msg.SynthesisErrorCodes()
      if self.states is None:
        self.states = None
      end = 0
      start = end
      end += 4
      (self.error_code.value,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.states = []
      for i in range(0, length):
        val1 = flexbe_msgs.msg.StateInstantiation()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.state_path = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.state_path = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.state_class = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.state_class = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.initial_state_name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.initial_state_name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.input_keys = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.input_keys.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.output_keys = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.output_keys.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.cond_outcome = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.cond_outcome.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.cond_transition = []
        for i in range(0, length):
          val2 = flexbe_msgs.msg.OutcomeCondition()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.state_name = []
          for i in range(0, length):
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3 = str[start:end].decode('utf-8', 'rosmsg')
            else:
              val3 = str[start:end]
            val2.state_name.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.state_outcome = []
          for i in range(0, length):
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3 = str[start:end].decode('utf-8', 'rosmsg')
            else:
              val3 = str[start:end]
            val2.state_outcome.append(val3)
          val1.cond_transition.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.behavior_class = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.behavior_class = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.parameter_names = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.parameter_names.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.parameter_values = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.parameter_values.append(val2)
        start = end
        end += 8
        val1.position = _get_struct_2f().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.outcomes = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.outcomes.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.transitions = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.transitions.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sb'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.autonomy = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.userdata_keys = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.userdata_keys.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.userdata_remapping = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.userdata_remapping.append(val2)
        self.states.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.error_code.value
      buff.write(_get_struct_i().pack(_x))
      length = len(self.states)
      buff.write(_struct_I.pack(length))
      for val1 in self.states:
        _x = val1.state_path
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.state_class
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.initial_state_name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.input_keys)
        buff.write(_struct_I.pack(length))
        for val2 in val1.input_keys:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.output_keys)
        buff.write(_struct_I.pack(length))
        for val2 in val1.output_keys:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.cond_outcome)
        buff.write(_struct_I.pack(length))
        for val2 in val1.cond_outcome:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.cond_transition)
        buff.write(_struct_I.pack(length))
        for val2 in val1.cond_transition:
          length = len(val2.state_name)
          buff.write(_struct_I.pack(length))
          for val3 in val2.state_name:
            length = len(val3)
            if python3 or type(val3) == unicode:
              val3 = val3.encode('utf-8')
              length = len(val3)
            buff.write(struct.Struct('<I%ss'%length).pack(length, val3))
          length = len(val2.state_outcome)
          buff.write(_struct_I.pack(length))
          for val3 in val2.state_outcome:
            length = len(val3)
            if python3 or type(val3) == unicode:
              val3 = val3.encode('utf-8')
              length = len(val3)
            buff.write(struct.Struct('<I%ss'%length).pack(length, val3))
        _x = val1.behavior_class
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.parameter_names)
        buff.write(_struct_I.pack(length))
        for val2 in val1.parameter_names:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.parameter_values)
        buff.write(_struct_I.pack(length))
        for val2 in val1.parameter_values:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        buff.write(val1.position.tostring())
        length = len(val1.outcomes)
        buff.write(_struct_I.pack(length))
        for val2 in val1.outcomes:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.transitions)
        buff.write(_struct_I.pack(length))
        for val2 in val1.transitions:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.autonomy)
        buff.write(_struct_I.pack(length))
        pattern = '<%sb'%length
        buff.write(val1.autonomy.tostring())
        length = len(val1.userdata_keys)
        buff.write(_struct_I.pack(length))
        for val2 in val1.userdata_keys:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
        length = len(val1.userdata_remapping)
        buff.write(_struct_I.pack(length))
        for val2 in val1.userdata_remapping:
          length = len(val2)
          if python3 or type(val2) == unicode:
            val2 = val2.encode('utf-8')
            length = len(val2)
          buff.write(struct.Struct('<I%ss'%length).pack(length, val2))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.error_code is None:
        self.error_code = flexbe_msgs.msg.SynthesisErrorCodes()
      if self.states is None:
        self.states = None
      end = 0
      start = end
      end += 4
      (self.error_code.value,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.states = []
      for i in range(0, length):
        val1 = flexbe_msgs.msg.StateInstantiation()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.state_path = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.state_path = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.state_class = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.state_class = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.initial_state_name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.initial_state_name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.input_keys = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.input_keys.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.output_keys = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.output_keys.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.cond_outcome = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.cond_outcome.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.cond_transition = []
        for i in range(0, length):
          val2 = flexbe_msgs.msg.OutcomeCondition()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.state_name = []
          for i in range(0, length):
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3 = str[start:end].decode('utf-8', 'rosmsg')
            else:
              val3 = str[start:end]
            val2.state_name.append(val3)
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          val2.state_outcome = []
          for i in range(0, length):
            start = end
            end += 4
            (length,) = _struct_I.unpack(str[start:end])
            start = end
            end += length
            if python3:
              val3 = str[start:end].decode('utf-8', 'rosmsg')
            else:
              val3 = str[start:end]
            val2.state_outcome.append(val3)
          val1.cond_transition.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.behavior_class = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.behavior_class = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.parameter_names = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.parameter_names.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.parameter_values = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.parameter_values.append(val2)
        start = end
        end += 8
        val1.position = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.outcomes = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.outcomes.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.transitions = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.transitions.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sb'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.autonomy = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.userdata_keys = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.userdata_keys.append(val2)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.userdata_remapping = []
        for i in range(0, length):
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2 = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2 = str[start:end]
          val1.userdata_remapping.append(val2)
        self.states.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2f = None
def _get_struct_2f():
    global _struct_2f
    if _struct_2f is None:
        _struct_2f = struct.Struct("<2f")
    return _struct_2f
_struct_i = None
def _get_struct_i():
    global _struct_i
    if _struct_i is None:
        _struct_i = struct.Struct("<i")
    return _struct_i
